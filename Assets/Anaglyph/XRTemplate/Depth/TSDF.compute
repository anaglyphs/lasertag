#include "../Depth/DepthKit.hlsl"

uint3 volumeSize; // dimensions of volume texture
float metersPerVoxel;
float distTruncate;
float3 chunkPos;
float maxEyeDist;
// RWTexture3D<half> volume; // tsdf
RWStructuredBuffer<half> volume;
SamplerState linearClampSampler;

//int numPlayers;
//float3 playerHeadsWorld[512];

#define PLAYER_TOP 0.2 
#define PLAYER_BOTTOM 1.7
#define PLAYER_RADIUS 0.5

half readVol(uint3 i)
{
	uint3 v = volumeSize;
	return volume[i.x + (i.y * v.x) + (i.z * v.x * v.y)];
}

void writeVol(uint3 i, half val)
{
	uint3 v = volumeSize;
	volume[i.x + (i.y * v.x) + (i.z * v.x * v.y)] = val;
}

float3 voxelToWorld(uint3 indices)
{
	float3 pos = indices;
	pos += 0.5f;
	pos -= volumeSize / 2.0f;
	pos *= metersPerVoxel;
	pos += chunkPos;
	
	return pos;
}

uint3 worldToVoxel(float3 pos)
{
	pos -= chunkPos;
	pos /= metersPerVoxel;
	pos += volumeSize / 2.0f;
	
	uint3 id = uint3(pos);
	id = clamp(id, 0, volumeSize);
	return id;
}

//float3 worldToVoxelUVW(float3 pos)
//{	
//	pos /= metersPerVoxel;
//	pos += volumeSize / 2.0f;
//	pos -= 0.5f;
//	pos /= volumeSize;
	
//	return saturate(pos);
//}

#pragma kernel Clear

[numthreads(4, 4, 4)]
void Clear(uint3 id : SV_DispatchThreadID)
{
	writeVol(id, 1);
}


#pragma kernel Integrate
 
[numthreads(8, 8, 8)]
void Integrate (uint3 i : SV_DispatchThreadID)
{
	uint3 id = i;
	
	float3 eyePos = agDepthEyePos();
	float3 voxPos = voxelToWorld(id);
	
	float4 voxHCS = agDepthWorldToHCS(voxPos);
	float3 voxNDC = agDepthHCStoNDC(voxHCS);
	
	float depth = agDepthSample(voxNDC.xy);
	
	float3 depthNDC = float3(voxNDC.xy, depth);
	float3 depthPos = agDepthNDCtoWorld(depthNDC);
	
	float voxEyeDist = distance(voxPos, eyePos);
	float depthEyeDist = distance(depthPos, eyePos);
	
	float sDist = depthEyeDist - voxEyeDist;
	half sDistNorm = sDist / distTruncate;
	sDistNorm = min(sDistNorm, 1);
	
	//bool inPlayer = false;
	
	//for (int i = 0; i < numPlayers; i++)
	//{
	//	float3 playerPos = playerHeadsWorld[i];
		
	//	if (distance(voxPos.xz, playerPos.xz) < PLAYER_RADIUS &&
	//		voxPos.y < playerPos.y + PLAYER_TOP &&
	//		voxPos.y > playerPos.y - PLAYER_BOTTOM)
	//	{
	//		inPlayer = true;
	//	}
	//}
	
	bool inView = voxNDC.x > 0.2 && voxNDC.x < 0.8 &&
					voxNDC.y > 0.2 && voxNDC.y < 0.8 &&
					voxHCS.z > 0; 
	
	bool withinMaxDist = voxEyeDist < maxEyeDist;
	
	if (sDistNorm > -1 && inView && withinMaxDist)// && !inPlayer)
		writeVol(id, sDistNorm);
}
 
//#pragma kernel Raycast

/// Raycast

//uniform float3 rcOrig; 
//uniform float3 rcDir;
//uniform float rcIntScale;
//RWStructuredBuffer<uint> rcResult;
//Texture3D<half> rcVolume;

//half sampleDist(float3 uvw)
//{
//	return rcVolume.SampleLevel(linearClampSampler, uvw, 0) * metersPerVoxel;
//}

//[numthreads(64, 1, 1)]
//void Raycast(uint3 id : SV_DispatchThreadID)
//{
//	float3 startPos = rcOrig + rcDir * metersPerVoxel * id.x;
//	float3 worldPos = startPos;
	
//	// each thread does a mini raymarch through the TSDF
//	for (int i = 0; i < 3; i++)
//	{
//		float3 uvw = worldToVoxelUVW(worldPos);
//		half signedDistance = sampleDist(uvw);
//		worldPos += rcDir * signedDistance;
//	}
	
//	float3 uvw = worldToVoxelUVW(worldPos);
//	half signedDistance = sampleDist(uvw);
	
//	float distanceFromCenter = distance(worldPos, rcOrig);
//	uint distFromCenterInt = distanceFromCenter * rcIntScale;
	
//	if (abs(signedDistance) < 0.02f)
//		InterlockedMin(rcResult[0], distFromCenterInt);
//}