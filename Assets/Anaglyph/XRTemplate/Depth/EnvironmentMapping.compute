#include "../Depth/DepthKit.hlsl"

uniform uint3 volumeSize; // dimensions of volume texture
uniform float voxSize;
uniform float truncMax;
uniform float truncMin;
RWTexture3D<half> volume; // tsdf
StructuredBuffer<float3> frustumVolume;
SamplerState linearClampSampler;

int numPlayers;
float3 playerHeadsWorld[512];

#define PLAYER_TOP 0.2
#define PLAYER_BOTTOM 1.7
#define PLAYER_RADIUS 0.5
#define MIN_DOT 0.3

float3 voxelToWorld(uint3 indices)
{
	float3 pos = indices;
	pos += 0.5f;
	pos -= volumeSize / 2.0f;
	pos *= voxSize;

	return pos;
}

uint3 worldToVoxel(float3 pos)
{
	pos /= voxSize;
	pos += volumeSize / 2.0f;

	uint3 id = uint3(pos);
	id = clamp(id, 0, volumeSize);
	return id;
}

float3 worldToVoxelUVW(float3 pos)
{
	pos /= voxSize;
	pos += volumeSize / 2.0f;
	pos -= 0.5f;
	pos /= volumeSize;

	return saturate(pos);
}

#pragma kernel Clear

[numthreads(4, 4, 4)]
void Clear(uint3 id : SV_DispatchThreadID)
{
	volume[id] = 1;
}


#pragma kernel Integrate

[numthreads(64, 1, 1)]
void Integrate(uint idx : SV_DispatchThreadID)
{
	float3 vLocalPos = frustumVolume[idx];
	float3 vWorldPos = mul(agDepthViewInv[0], float4(vLocalPos, 1)).xyz;
	uint3 coord = worldToVoxel(vWorldPos);

	float3 eyePos = agDepthEyePos();
	float3 voxPos = voxelToWorld(coord);

	float4 voxHCS = agDepthWorldToHCS(voxPos);
	float3 voxNDC = agDepthHCStoNDC(voxHCS);

	float depth = agDepthSample(voxNDC.xy);

	float3 depthNDC = float3(voxNDC.xy, depth);
	float3 depthPos = agDepthNDCtoWorld(depthNDC);

	float voxEyeDist = distance(voxPos, eyePos);
	float depthEyeDist = distance(depthPos, eyePos);

	float3 eyeToVox = voxPos - eyePos;
	float3 depthNorm = agDepthNormalSample(voxNDC.xy);

	float sDist = depthEyeDist - voxEyeDist;
	float normDot = -dot(normalize(eyeToVox), depthNorm);
	sDist *= saturate(normDot);

	half distSNorm = sDist / truncMax;
	distSNorm = min(distSNorm, 1);

	bool inPlayer = false;

	for (int p = 0; p < numPlayers; p++)
	{
		float3 playerPos = playerHeadsWorld[p];

		if (distance(vWorldPos.xz, playerPos.xz) < PLAYER_RADIUS &&
			vWorldPos.y < playerPos.y + PLAYER_TOP &&
			vWorldPos.y > playerPos.y - PLAYER_BOTTOM)
		{
			inPlayer = true;
		}
	}

	// todo use full sbyte range
	half truncMinNorm = truncMin / truncMax;
	if (distSNorm > truncMinNorm && !inPlayer && normDot > MIN_DOT)
		volume[coord.xyz] = distSNorm;
}

// Raymarch

struct RaymarchRequest
{
	float4 origin;
	float3 direction;
	float maxDistance;
};

uint numRaymarchRequests;
StructuredBuffer<RaymarchRequest> raymarchRequests;
RWStructuredBuffer<float> raymarchResults;
Texture3D<half> raymarchVolume;

half raymarchSample(float3 worldPos)
{
	float3 uvw = worldToVoxelUVW(worldPos);
	return raymarchVolume.SampleLevel(linearClampSampler, uvw, 0) * truncMax;
}

#pragma kernel Raymarch

[numthreads(64, 1, 1)]
void Raymarch(uint3 idx : SV_DispatchThreadID)
{
	float result = -1;

	if (idx.x >= numRaymarchRequests)
		return;

	const float3 origin = raymarchRequests[idx.x].origin;
	const float3 direction = normalize(raymarchRequests[idx.x].direction);
	float maxDist = raymarchRequests[idx.x].maxDistance;

	const uint maxSteps = maxDist / truncMax;

	float dist = 0;

	for (uint i = 0; i < maxSteps; i++)
	{
		float3 pos = origin + direction * dist;
		float val = raymarchSample(pos);
		dist += val;

		if (abs(val) < 0.01)
		{
			result = dist;
			break;
		}
	}

	raymarchResults[idx.x] = result;
}

#pragma kernel OcclusionMarch

#define MAX_RAYMARCH_DIST 100

float4x4 camView;
float4x4 camProj;
float4x4 camInvView;
float4x4 camInvProj;

RWTexture2D<half> occlusionTex;
uint2 occlusionTexSize;

[numthreads(8, 8, 1)]
void OcclusionMarch(uint2 idx : SV_DispatchThreadID)
{
	if (idx.x >= occlusionTexSize.x || idx.y >= occlusionTexSize.y)
		return;

	float2 uv = float2(idx) / float2(occlusionTexSize);
	// occlusionTex[idx.xy] = uv;
	// return;
	
	float2 ndc = uv * 2.0 - 1.0;

	float4 viewPos = mul(camInvProj, float4(ndc, 1.0, 1.0));
	viewPos.xyz /= viewPos.w;

	float3 origin = mul(camInvView, float4(0, 0, 0, 1)).xyz;
	float3 farPoint = mul(camInvView, float4(viewPos.xyz, 1)).xyz;
	float3 direction = normalize(farPoint - origin);

	float dist = 0;
	float stepScale = 1.0;
	uint maxSteps = (uint)(MAX_RAYMARCH_DIST / stepScale);

	float hitDist = MAX_RAYMARCH_DIST;

	for (uint i = 0; i < maxSteps; i++)
	{
		float3 pos = origin + direction * dist;
		float val = raymarchSample(pos);

		dist += val;

		if (abs(val) < 0.01)
		{
			hitDist = dist;
			break;
		}
	}
	// occlusionTex[idx] = dist / 10.0;
	// return;

	float4 clip = mul(camProj, mul(camView, float4(origin + direction * hitDist, 1.0)));
	float zdepth = clip.z / clip.w;
	zdepth = saturate(zdepth);

	occlusionTex[idx] = zdepth;
	return;
}
